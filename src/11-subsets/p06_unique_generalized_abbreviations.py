from src.testutils import contains_same_elements
from collections import deque

"""
Given a word, write a function to generate all of its unique generalized abbreviations.

A generalized abbreviation of a word can be generated by replacing each substring of the word with
the count of characters in the substring. Take the example of "ab" which has four substring: "",
"a", "b", and "ab". After replacing these substring in the actual word by the count of the 
characters, we get all the generalized abbreviations "ab", "1b", "a1", and "2".

Note: All contiguous characters should be considered one substring, e.g., we can't take "a" and "b"
as substrings to get "11"; since "a" and "b" are contiguous, we should consider them as one 
substring to get an abbreviation "2".
"""


class Abbreviation():
    def __init__(self, string, taken, prev_abb):
        self.string = string
        self.taken = taken
        self.prev_abb = prev_abb


def generalized_abb(word):
    """
    Time Complexity:  O(n * 2^n) - every character can either be kept or abbreviated.
    Space Complexity: O(n * 2^n)
    """
    results = []
    queue = deque([Abbreviation("", 0, False)])

    while len(queue) > 0:
        abb = queue.popleft()

        # Take the next letter.
        new_abb = Abbreviation(
            abb.string + word[abb.taken], abb.taken + 1, False)

        if new_abb.taken == len(word):
            results.append(new_abb.string)
        else:
            queue.append(new_abb)

        # If the previous character was an abbreviation, this one cannot be. Don't add any
        # abbreviations to this position.
        if abb.prev_abb:
            continue

        # Take any number from 1 to the remaining letters to take.
        # This loop accounts for 1 to the remaining letters to take - 1, since these are guaranteed
        # to not yet be finished abbreviations yet, going back into the queue.
        i = 1
        while i < len(word) - abb.taken:
            new_abb = Abbreviation(
                abb.string + str(i), abb.taken + i, True)
            queue.append(new_abb)
            i += 1

        # The final option with a number covering the remaining letters. This is a finished
        # abbreviation and should be accumulated as a result.
        results.append(abb.string + str(i))

    return results


def test_ex1():
    word = "BAT"
    actual = generalized_abb(word)
    expected = ["BAT", "BA1", "B1T", "B2", "1AT", "1A1", "2T", "3"]
    assert contains_same_elements(actual, expected)


def test_ex2():
    word = "code"
    actual = generalized_abb(word)
    expected = ["code", "cod1", "co1e", "co2", "c1de", "c1d1", "c2e", "c3", "1ode", "1od1", "1o1e", "1o2",
                "2de", "2d1", "3e", "4"]
    assert contains_same_elements(actual, expected)
